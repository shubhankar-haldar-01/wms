const express = require("express");
const Joi = require("joi");
const { pool } = require("../config/database");
const { authenticateToken, requireRole } = require("../middleware/auth");
const { ensureStockConsistency } = require("../middleware/stockConsistency");

const router = express.Router();

// Configuration constants - removed 5-minute timeout logic

// Function to validate if barcode was generated by the system
function isSystemGeneratedBarcode(barcode) {
  // System-generated barcodes follow pattern: ${product_id}${timestamp}${index}
  // They should be numeric and have a reasonable length (at least 10 characters)
  if (!/^\d+$/.test(barcode) || barcode.length < 10) {
    return false;
  }

  // Additional validation: check if it exists in our barcodes table
  // This ensures it was actually generated by our system
  return true; // We'll check existence in the database query
}

// Function to validate barcode exists in our system
async function validateBarcodeExists(barcode) {
  const [result] = await pool.execute(
    "SELECT id FROM barcodes WHERE barcode = ?",
    [barcode]
  );
  return result.length > 0;
}

// Validation schema for barcode lookup
const barcodeLookupSchema = Joi.object({
  barcode: Joi.string().required(),
});

// Validation schema for stock update via barcode
const barcodeStockUpdateSchema = Joi.object({
  barcode: Joi.string().required(),
  type: Joi.string().valid("in", "out").required(),
  quantity: Joi.number().integer().min(1).required(),
  notes: Joi.string().allow(""),
});

// Look up product by barcode
router.post("/lookup", authenticateToken, async (req, res) => {
  try {
    const { error } = barcodeLookupSchema.validate(req.body);
    if (error) {
      return res.status(400).json({
        success: false,
        message: error.details[0].message,
      });
    }

    const { barcode } = req.body;

    // Look up barcode and get product details
    const [barcodeRows] = await pool.execute(
      `
      SELECT 
        b.*,
        p.name as product_name,
        p.sku as product_sku,
        p.price as product_price,
        '' as product_description,
        p.stock_quantity as current_stock,
        p.low_stock_threshold
      FROM barcodes b
      JOIN products p ON b.product_id = p.id
      WHERE b.barcode = ?
    `,
      [barcode]
    );

    if (barcodeRows.length === 0) {
      return res.status(404).json({
        success: false,
        message: "Barcode not found",
      });
    }

    const barcodeData = barcodeRows[0];

    // Check if this is a system-generated barcode
    const isSystemGenerated = isSystemGeneratedBarcode(barcode);

    res.json({
      success: true,
      data: {
        barcode: barcodeData.barcode,
        product: {
          id: barcodeData.product_id,
          name: barcodeData.product_name,
          sku: barcodeData.product_sku,
          price: barcodeData.product_price,
          description: barcodeData.product_description,
        },
        stock: {
          current: barcodeData.current_stock,
          low_threshold: barcodeData.low_stock_threshold,
          status:
            barcodeData.current_stock <= barcodeData.low_stock_threshold
              ? "low"
              : "normal",
        },
        isSystemGenerated,
        unitsAssigned: barcodeData.units_assigned,
        createdAt: barcodeData.created_at,
      },
    });
  } catch (error) {
    console.error("Barcode lookup error:", error);
    res.status(500).json({
      success: false,
      message: "Internal server error",
    });
  }
});

// Update stock via barcode scan
router.post("/update-stock", authenticateToken, async (req, res) => {
  let connection;
  try {
    const { error } = barcodeStockUpdateSchema.validate(req.body);
    if (error) {
      return res.status(400).json({
        success: false,
        message: error.details[0].message,
      });
    }

    const { barcode, type, quantity, notes = "" } = req.body;

    connection = await pool.getConnection();
    await connection.beginTransaction();

    // Get barcode and product details with stock status
    const [barcodeRows] = await connection.execute(
      `
      SELECT 
        b.*,
        p.name as product_name,
        p.sku as product_sku,
        p.stock_quantity as current_stock
      FROM barcodes b
      JOIN products p ON b.product_id = p.id
      WHERE b.barcode = ?
    `,
      [barcode]
    );

    if (barcodeRows.length === 0) {
      await connection.rollback();
      return res.status(404).json({
        success: false,
        message: "Barcode not found",
      });
    }

    const barcodeData = barcodeRows[0];

    // Simple barcode status check - only check is_stocked_in flag
    // For stock IN: check if currently stocked in
    if (type === "in") {
      if (barcodeData.is_stocked_in) {
        await connection.rollback();
        return res.status(400).json({
          success: false,
          message:
            "This barcode is already stocked in. Cannot stock in again until it's stocked out.",
          data: {
            barcode: barcode,
            product: {
              name: barcodeData.product_name,
              sku: barcodeData.product_sku,
            },
            rule: "Stock In Only Once Until Stock Out",
            currentStatus: "Already Stocked In",
          },
        });
      }
    }

    // For stock OUT: check if barcode is currently stocked in
    if (type === "out") {
      if (!barcodeData.is_stocked_in) {
        await connection.rollback();
        return res.status(400).json({
          success: false,
          message:
            "Cannot stock out! This barcode is not currently stocked in.",
          data: {
            barcode: barcode,
            product: {
              name: barcodeData.product_name,
              sku: barcodeData.product_sku,
            },
            rule: "Barcode Must Be Currently Stocked In",
            currentStatus: "Not Stocked In",
          },
        });
      }
    }

    // Calculate new stock quantity based on stocked-in barcodes count
    const currentStock = barcodeData.current_stock;

    // Validate stock out operations - check sufficient stock
    if (type === "out") {
      if (currentStock < quantity) {
        await connection.rollback();
        return res.status(400).json({
          success: false,
          message: `Insufficient stock! Current stock: ${currentStock}, Requested: ${quantity}. Cannot perform stock out operation.`,
          data: {
            currentStock,
            requestedQuantity: quantity,
            shortfall: quantity - currentStock,
          },
        });
      }
    }

    // Calculate new stock quantity based on current stock and transaction
    const newStock =
      type === "in" ? currentStock + quantity : currentStock - quantity;

    // Create transaction with barcode_id
    const [transactionResult] = await connection.execute(
      `
      INSERT INTO transactions (
        product_id, 
        barcode_id,
        type, 
        quantity, 
        reference_number, 
        notes, 
        user_id, 
        created_at, 
        updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, NOW(), NOW())
    `,
      [
        barcodeData.product_id,
        barcodeData.id, // Include the barcode ID
        type,
        quantity,
        `SCAN_${Date.now()}`,
        `${notes} | Barcode: ${barcode}`,
        req.user.id,
      ]
    );

    // Update barcode status and units assigned based on transaction type
    if (type === "in") {
      // Mark barcode as stocked in and set units assigned to quantity
      // Ensure units_assigned is at least 1 if quantity is 0 or undefined
      const unitsToAssign = Math.max(quantity || 1, 1);
      await connection.execute(
        `
        UPDATE barcodes 
        SET is_stocked_in = TRUE, units_assigned = ?, updated_at = NOW() 
        WHERE barcode = ?
      `,
        [unitsToAssign, barcode]
      );
    } else if (type === "out") {
      // Mark barcode as stocked out and reset units assigned to 0
      await connection.execute(
        `
        UPDATE barcodes 
        SET is_stocked_in = FALSE, units_assigned = 0, updated_at = NOW() 
        WHERE barcode = ?
      `,
        [barcode]
      );
    }

    // Ensure stock consistency across all tables AFTER updating barcode status
    const totalUnits = await ensureStockConsistency(
      connection,
      barcodeData.product_id
    );

    await connection.commit();

    res.json({
      success: true,
      message: "Stock updated successfully",
      data: {
        barcode: barcodeData.barcode,
        product: {
          name: barcodeData.product_name,
          sku: barcodeData.product_sku,
        },
        transaction: {
          type,
          quantity,
          previousStock: currentStock,
          newStock,
        },
        transactionId: transactionResult.insertId,
      },
    });
  } catch (error) {
    if (connection) {
      await connection.rollback();
    }
    console.error("Barcode stock update error:", error);
    res.status(500).json({
      success: false,
      message: "Internal server error",
    });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});

// Get scan history for a barcode
router.get("/history/:barcode", authenticateToken, async (req, res) => {
  try {
    const { barcode } = req.params;
    const { page = 1, limit = 20 } = req.query;
    const offset = (page - 1) * limit;

    // Get barcode details first
    const [barcodeRows] = await pool.execute(
      `
      SELECT b.*, p.name as product_name, p.sku as product_sku
      FROM barcodes b
      JOIN products p ON b.product_id = p.id
      WHERE b.barcode = ?
    `,
      [barcode]
    );

    if (barcodeRows.length === 0) {
      return res.status(404).json({
        success: false,
        message: "Barcode not found",
      });
    }

    const barcodeData = barcodeRows[0];

    // Get scan history
    const [history] = await pool.execute(
      `
      SELECT 
        t.*,
        u.username as created_by_username
      FROM transactions t
      LEFT JOIN users u ON t.user_id = u.id
      WHERE t.product_id = ? 
        AND t.notes LIKE ?
      ORDER BY t.created_at DESC
      LIMIT ${parseInt(limit)} OFFSET ${parseInt(offset)}
    `,
      [barcodeData.product_id, `%Barcode: ${barcode}%`]
    );

    // Get total count
    const [countResult] = await pool.execute(
      `
      SELECT COUNT(*) as total
      FROM transactions
      WHERE product_id = ? 
        AND notes LIKE ?
    `,
      [barcodeData.product_id, `%Barcode: ${barcode}%`]
    );

    res.json({
      success: true,
      data: {
        barcode: barcodeData,
        history,
        pagination: {
          page: parseInt(page),
          limit: parseInt(limit),
          total: countResult[0].total,
          pages: Math.ceil(countResult[0].total / limit),
        },
      },
    });
  } catch (error) {
    console.error("Get barcode scan history error:", error);
    res.status(500).json({
      success: false,
      message: "Internal server error",
    });
  }
});

// Bulk barcode lookup
router.post("/bulk-lookup", authenticateToken, async (req, res) => {
  try {
    const { barcodes } = req.body;

    if (!Array.isArray(barcodes) || barcodes.length === 0) {
      return res.status(400).json({
        success: false,
        message: "Barcodes array is required",
      });
    }

    if (barcodes.length > 100) {
      return res.status(400).json({
        success: false,
        message: "Maximum 100 barcodes allowed per request",
      });
    }

    const placeholders = barcodes.map(() => "?").join(",");
    const [results] = await pool.execute(
      `
      SELECT 
        b.*,
        p.name as product_name,
        p.sku as product_sku,
        p.price as product_price,
        p.stock_quantity as current_stock,
        p.low_stock_threshold
      FROM barcodes b
      JOIN products p ON b.product_id = p.id
      WHERE b.barcode IN (${placeholders})
    `,
      barcodes
    );

    const foundBarcodes = results.map((row) => ({
      barcode: row.barcode,
      product: {
        id: row.product_id,
        name: row.product_name,
        sku: row.product_sku,
        price: row.product_price,
      },
      stock: {
        current: row.current_stock,
        low_threshold: row.low_stock_threshold,
        status: row.current_stock <= row.low_stock_threshold ? "low" : "normal",
      },
      isSystemGenerated: isSystemGeneratedBarcode(row.barcode),
      unitsAssigned: row.units_assigned,
    }));

    const foundBarcodeNumbers = foundBarcodes.map((item) => item.barcode);
    const notFoundBarcodes = barcodes.filter(
      (barcode) => !foundBarcodeNumbers.includes(barcode)
    );

    res.json({
      success: true,
      data: {
        found: foundBarcodes,
        notFound: notFoundBarcodes,
        summary: {
          total: barcodes.length,
          found: foundBarcodes.length,
          notFound: notFoundBarcodes.length,
        },
      },
    });
  } catch (error) {
    console.error("Bulk barcode lookup error:", error);
    res.status(500).json({
      success: false,
      message: "Internal server error",
    });
  }
});

// Get scanning stats (last 7 days)
router.get("/stats", authenticateToken, async (req, res) => {
  try {
    const { days = 7 } = req.query;

    // Get scanning statistics - show historical transaction counts
    const [stats] = await pool.execute(
      `
      SELECT 
        (SELECT COUNT(*) FROM transactions WHERE type = 'in' AND created_at >= DATE_SUB(CURDATE(), INTERVAL ${parseInt(
          days
        )} DAY) AND notes LIKE '%Barcode:%') as stock_in_scans,
        (SELECT COUNT(*) FROM transactions WHERE type = 'out' AND created_at >= DATE_SUB(CURDATE(), INTERVAL ${parseInt(
          days
        )} DAY) AND notes LIKE '%Barcode:%') as stock_out_scans,
        (SELECT COUNT(*) FROM transactions WHERE created_at >= DATE_SUB(CURDATE(), INTERVAL ${parseInt(
          days
        )} DAY) AND notes LIKE '%Barcode:%') as total_scans,
        (SELECT COUNT(DISTINCT product_id) FROM transactions WHERE created_at >= DATE_SUB(CURDATE(), INTERVAL ${parseInt(
          days
        )} DAY) AND notes LIKE '%Barcode:%') as unique_products_scanned,
        (SELECT COUNT(DISTINCT user_id) FROM transactions WHERE created_at >= DATE_SUB(CURDATE(), INTERVAL ${parseInt(
          days
        )} DAY) AND notes LIKE '%Barcode:%') as active_users,
        CURDATE() as scan_date
    `
    );

    // Get daily breakdown
    const [dailyBreakdown] = await pool.execute(
      `
      SELECT 
        DATE(created_at) as date,
        type,
        COUNT(*) as count,
        SUM(quantity) as total_quantity
      FROM transactions
      WHERE created_at >= DATE_SUB(CURDATE(), INTERVAL ${parseInt(days)} DAY)
        AND notes LIKE '%Barcode:%'
      GROUP BY DATE(created_at), type
      ORDER BY date DESC, type
    `
    );

    // Get top scanned products
    const [topProducts] = await pool.execute(
      `
      SELECT 
        p.name as product_name,
        p.sku as product_sku,
        COUNT(t.id) as scan_count,
        SUM(CASE WHEN t.type = 'in' THEN t.quantity ELSE 0 END) as total_in,
        SUM(CASE WHEN t.type = 'out' THEN t.quantity ELSE 0 END) as total_out
      FROM transactions t
      JOIN products p ON t.product_id = p.id
      WHERE t.created_at >= DATE_SUB(CURDATE(), INTERVAL ${parseInt(days)} DAY)
        AND t.notes LIKE '%Barcode:%'
      GROUP BY p.id, p.name, p.sku
      ORDER BY scan_count DESC
      LIMIT 10
    `
    );

    res.json({
      success: true,
      data: {
        summary: stats[0] || {
          total_scans: 0,
          stock_in_scans: 0,
          stock_out_scans: 0,
          unique_products_scanned: 0,
          active_users: 0,
        },
        dailyBreakdown,
        topProducts,
        period: parseInt(days),
      },
    });
  } catch (error) {
    console.error("Get scanning stats error:", error);
    res.status(500).json({
      success: false,
      message: "Internal server error",
    });
  }
});

// Get scan history (alias for recent scans)
router.get("/scan-history", authenticateToken, async (req, res) => {
  try {
    const { limit = 20, type } = req.query;

    let query = `
      SELECT 
        t.*,
        p.name as product_name,
        p.sku as product_sku,
        u.username as scanned_by
      FROM transactions t
      JOIN products p ON t.product_id = p.id
      LEFT JOIN users u ON t.user_id = u.id
      WHERE t.notes LIKE '%Barcode:%' OR t.notes LIKE '%SCAN_%'
    `;

    const params = [];

    if (type && ["in", "out"].includes(type)) {
      query += " AND t.type = ?";
      params.push(type);
    }

    query += ` ORDER BY t.created_at DESC LIMIT ${parseInt(limit)}`;

    const [recentScans] = await pool.execute(query, params);

    res.json({
      success: true,
      data: recentScans,
    });
  } catch (error) {
    console.error("Get scan history error:", error);
    res.status(500).json({
      success: false,
      message: "Internal server error",
    });
  }
});

// Get recent scans
router.get("/recent", authenticateToken, async (req, res) => {
  try {
    const { limit = 20, type } = req.query;

    let query = `
      SELECT 
        t.*,
        p.name as product_name,
        p.sku as product_sku,
        u.username as scanned_by
      FROM transactions t
      JOIN products p ON t.product_id = p.id
      LEFT JOIN users u ON t.user_id = u.id
      WHERE t.notes LIKE '%Barcode:%' OR t.notes LIKE '%SCAN_%'
    `;

    const params = [];

    if (type && ["in", "out"].includes(type)) {
      query += " AND t.type = ?";
      params.push(type);
    }

    query += ` ORDER BY t.created_at DESC LIMIT ${parseInt(limit)}`;

    const [recentScans] = await pool.execute(query, params);

    res.json({
      success: true,
      data: recentScans,
    });
  } catch (error) {
    console.error("Get recent scans error:", error);
    res.status(500).json({
      success: false,
      message: "Internal server error",
    });
  }
});

// Check if barcode was already stocked in - OPTIMIZED
router.get("/check-stock-in/:barcode", authenticateToken, async (req, res) => {
  try {
    const { barcode } = req.params;

    // Simple check using only is_stocked_in flag - much faster
    const [result] = await pool.execute(
      `SELECT is_stocked_in FROM barcodes WHERE barcode = ?`,
      [barcode]
    );

    if (result.length === 0) {
      return res.status(404).json({
        success: false,
        message: "Barcode not found",
      });
    }

    const alreadyStockedIn = result[0].is_stocked_in;

    res.json({
      success: true,
      data: {
        alreadyStockedIn,
        barcode,
        isStockedIn: alreadyStockedIn,
      },
    });
  } catch (error) {
    console.error("Check stock-in error:", error);
    res.status(500).json({
      success: false,
      message: "Internal server error",
    });
  }
});

// Get scanning activity by hour (for charts)
router.get("/activity", authenticateToken, async (req, res) => {
  try {
    const { days = 7 } = req.query;

    const [activity] = await pool.execute(
      `
      SELECT 
        HOUR(created_at) as hour,
        type,
        COUNT(*) as count
      FROM transactions
      WHERE created_at >= DATE_SUB(NOW(), INTERVAL ${parseInt(days)} DAY)
        AND notes LIKE '%Barcode:%'
      GROUP BY HOUR(created_at), type
      ORDER BY hour, type
    `
    );

    res.json({
      success: true,
      data: activity,
    });
  } catch (error) {
    console.error("Get scanning activity error:", error);
    res.status(500).json({
      success: false,
      message: "Internal server error",
    });
  }
});

module.exports = router;
